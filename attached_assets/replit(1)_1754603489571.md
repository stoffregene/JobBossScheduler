# Replit Agent Implementation Guide

This guide contains **two independent code patches** your Replit agent should apply to bring the JobBossScheduler backend in line with project requirements:

1. **Dynamic Work‑Center Prefix Discovery** ( importer fix ) – _already documented, kept unchanged below_.
2. **Operator‑Aligned Auto‑Scheduler Overhaul** – *new in this version*; closes the logic gaps that mis‑align operation start‑times with the selected employee.

---

## 1 ️⃣ Dynamic Work‑Center Prefix Fix  *(unchanged)*
> **Purpose** Replace the hard‑coded `standardWorkCenters` list in `server/routes.ts` with a **dynamic** list built from the prefixes that already exist in `data/machine_matrix.csv`.  This keeps the importer in sync with your real shop‑floor cells (`TUMBLE‑001`, `DEBURR‑001`, etc.) without having to edit code each time a new work‑center is added.

### Implementation steps
<details>
<summary>Click to view</summary>

1. **Add CSV dependency**
   ```bash
   npm install csv-parse@5 --save
   ```
2. **Create helper** `server/utils/workCenterPrefixes.ts`
   ```ts
   // … (same code as previous version) …
   ```
3. **Modify** `server/routes.ts`
   ```diff
   // … (same diff as previous version) …
   ```
4. **Run tests** – ensure zero unknown‑WC warnings.
5. **Commit** – `git commit -m "feat: dynamic work‑center prefix discovery"`

</details>

---

## 2 ️⃣ Operator‑Aligned Auto‑Scheduler Overhaul  *(NEW)*

### Objectives
* **Finish** the stubbed scheduler methods so they truly create `ScheduleEntry` rows.
* Always pick the **next available window** that fits *both* machine **and** operator.
* Snap all times to shift boundaries and keep everything in UTC internally.
* Enforce resource locking on **machines and operators** simultaneously.
* Apply the 24‑hour Saw/Waterjet lag rule.

### File & Code changes

| File | Action |
|------|--------|
| `server/operator-availability-manager.ts` | **Add** `getNextAvailableWindow()` & `lockOperatorUntil()` APIs. |
| `server/shift-utils.ts` *(new)* | **Provide** `roundToShiftStart()`, `advancePastShiftEnd()`, and central shift definitions. |
| `server/auto-scheduler.ts` *(new)* | **Implement** the full scheduling loop outlined below; imported by `database-storage.ts`. |
| `server/database-storage.ts` | **Replace** placeholder implementations of `scheduleJobsByPriority()`, `autoScheduleJob()`, `manualScheduleJob()` to call the new scheduler. |
| `tests/test-operator-locking.js` *(new)* | **Add** regression test that asserts no operator overlap & start ≥ shift-start. |

> **Note:** All timestamps must be stored as **UTC** `Date` objects. When parsing shift strings use `luxon` for robust zone handling.

### Step‑by‑step (Replit agent script)

1. **Install luxon**
   ```bash
   npm install luxon@3 --save
   ```
2. **Create** `server/shift-utils.ts`
   ```ts
   import { DateTime, Duration } from "luxon";

   export const SHIFT_DEFS = [
     { name: "1st", start: "06:00", end: "16:00" },
     { name: "2nd", start: "16:00", end: "02:00+1" } // +1 = next day
   ];

   const tz = "America/Chicago";

   export function roundToShiftStart(dt: DateTime) {
     for (const s of SHIFT_DEFS) {
       const start = DateTime.fromISO(`${dt.toISODate()}T${s.start}`, { zone: tz });
       const end   = DateTime.fromISO(`${dt.toISODate()}T${s.end}`,   { zone: tz });
       if (dt < start) return start;
       if (dt >= start && dt < end) return dt; // already inside shift
     }
     // after 2nd shift → jump to next day's 1st shift
     return DateTime.fromISO(`${dt.plus({ days: 1 }).toISODate()}T${SHIFT_DEFS[0].start}`, { zone: tz });
   }

   export function advancePastShiftEnd(dt: DateTime) {
     for (const s of SHIFT_DEFS) {
       const end = DateTime.fromISO(`${dt.toISODate()}T${s.end}`, { zone: tz });
       if (dt < end) return end;
     }
     return roundToShiftStart(dt.plus({ days: 1 }));
   }
   ```
3. **Extend** `operator-availability-manager.ts`
   ```ts
   import { DateTime, Duration } from "luxon";
   import { roundToShiftStart, advancePastShiftEnd } from "./shift-utils";

   // existing interface…
   export function getNextAvailableWindow(
     operatorId: string,
     durationHrs: number,
     earliestStart: Date
   ): { start: Date; end: Date } {
     let dt = roundToShiftStart(DateTime.fromJSDate(earliestStart));
     while (true) {
       if (isOperatorAvailable(operatorId, dt.toJSDate(), durationHrs)) {
         const end = dt.plus({ hours: durationHrs });
         return { start: dt.toUTC().toJSDate(), end: end.toUTC().toJSDate() };
       }
       dt = advancePastShiftEnd(dt);
     }
   }

   export function lockOperatorUntil(opId: string, until: Date) {
     // update in‑memory map or DB row
   }
   ```
4. **Create** `server/auto-scheduler.ts`
   ```ts
   import {
     getNextAvailableWindow, lockOperatorUntil
   } from "./operator-availability-manager";
   import { barFeederRequired } from "./bar-feeder-service";
   import { DateTime } from "luxon";

   export async function scheduleJob(job, routingOps) {
     let earliest = DateTime.fromISO(job.createdDate).plus({ days: 7 });
     let machineLocked = new Map<string, DateTime>();

     for (const op of routingOps) {
       if (op.isVirtual) continue;
       const machine = await selectMachine(op, machineLocked);
       const operator = await selectOperator(op, machine);
       if (!machine || !operator) throw new Error("No resource match");

       const { start, end } = getNextAvailableWindow(
         operator.id,
         op.durationHrs,
         earliest.toJSDate()
       );

       await persistScheduleEntry(job.id, op.seq, machine.id, operator.id, start, end);
       machineLocked.set(machine.id, DateTime.fromJSDate(end));
       lockOperatorUntil(operator.id, end);

       // 24‑hour lag after saw / waterjet
       earliest = DateTime.fromJSDate(end);
       if (["SAW", "WATERJET"].includes(op.machinePrefix)) {
         earliest = earliest.plus({ days: 1 }).startOf("day");
       }
     }
   }
   ```
5. **Replace** stubbed methods in `database-storage.ts` to call `scheduleJob()`.
6. **Add unit tests** in `tests/` – sample provided earlier.

### Acceptance criteria
| Test | Pass condition |
|------|----------------|
| **Operator overlap** | Running `tests/test-operator-locking.js` shows **0 overlapping entries** for a single operator. |
| **Shift rounding** | All scheduled `startTime` values fall *on or after* shift start; none inside lunch gaps. |
| **Saw / WJ lag** | Next operation for those jobs starts ≥ 24 h after the saw/waterjet `endTime`. |

---

## Commit sequence
```bash
# dynamic prefixes already committed (see section 1)

# new scheduler overhaul
npm install luxon@3 --save

# add new utils & replace stubs
git add server/shift-utils.ts server/auto-scheduler.ts \
        server/operator-availability-manager.ts \
        server/database-storage.ts tests/test-operator-locking.js

git commit -m "feat: operator‑aligned scheduler, shift rounding, resource locking"
git push origin main
```

---

### Final Note
These two patches are independent; apply **section 1** first (importer fix) then **section 2** (scheduler overhaul).  Restart the dev server after each patch to load new modules and pick up refreshed prefix lists.

