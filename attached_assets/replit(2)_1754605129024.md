# **JobBossScheduler — Replit Agent STRICT Patch Plan**

> **Read me verbatim.**  Do **nothing** beyond the steps and code blocks shown. No package upgrades, no refactors, no lint‑fix runs.  Apply Section A first, then Section B.  Push each commit separately.

---

## A – Dynamic Work‑Center Prefix Discovery

*Fixes unknown‑work‑center warnings (TUMBLE‑001, DEBURR‑001, …)*

### 1  Install runtime CSV parser

```bash
npm install csv-parse@5 --save
```

### 2  Add file `server/utils/workCenterPrefixes.ts`

```ts
import fs from "fs";
import path from "path";
import { parse } from "csv-parse/sync";

/**
 * Reads data/machine_matrix.csv, extracts the alphabetical prefix before the
 * first dash (e.g. "TUMBLE" from "TUMBLE-001") and returns a unique list.
 */
export function getWorkCenterPrefixes(): string[] {
  const csvPath = path.resolve(__dirname, "../../data/machine_matrix.csv");
  if (!fs.existsSync(csvPath)) {
    console.warn("⚠️  machine_matrix.csv not found:", csvPath);
    return [];
  }

  const raw = fs.readFileSync(csvPath, "utf8");
  const records = parse(raw, { columns: true, skip_empty_lines: true });
  const prefixes = new Set<string>();

  records.forEach((row: any) => {
    const code: string = (row.machineCode ?? "").toString().trim().toUpperCase();
    const match = code.match(/^([A-Z\s]+?)-\d+/);
    if (match) prefixes.add(match[1].trim());
  });

  return Array.from(prefixes);
}
```

### 3  Edit `server/routes.ts`  — **exact diff**

```diff
@@
-import express from "express";
-import multer  from "multer";
-// … other imports …
-
-// STATIC list – REMOVE ENTIRE BLOCK
-const standardWorkCenters = [
-  "SAW", "MILL", "LATHE", "WATERJET",
-  "BEAD BLAST", "WELD", "INSPECT",
-  "ASSEMBLE", "VMC", "HMC"
-];
-
-const isStandardWorkCenter = (wc: string) =>
-  standardWorkCenters.some(s => wc.toUpperCase().includes(s.toUpperCase()));
+import { getWorkCenterPrefixes } from "./utils/workCenterPrefixes";
+
+// Dynamic list derived from machine_matrix.csv
+const standardWorkCenters = getWorkCenterPrefixes();
+
+const isStandardWorkCenter = (wc: string) => {
+  if (!wc) return false;
+  const val = wc.toUpperCase();
+  return standardWorkCenters.some(prefix => val.includes(prefix));
+};
```

### 4  Commit & push **only Section A**

```bash
git add package.json package-lock.json \
        server/utils/workCenterPrefixes.ts server/routes.ts

git commit -m "feat(import): dynamic work‑center prefix discovery"
git push origin main
```

---

## B – Operator‑Aligned Auto‑Scheduler Overhaul

### 0  Install Luxon for TZ‑safe math

```bash
npm install luxon@3 --save
```

### 1  Create `server/shift-utils.ts`

```ts
import { DateTime } from "luxon";

export const SHIFT_DEFS = [
  { name: "1st", start: "06:00", end: "16:00" },
  { name: "2nd", start: "16:00", end: "02:00+1" } // +1 = next day
];

const TZ = "America/Chicago";

export function roundToShiftStart(dt: DateTime): DateTime {
  for (const s of SHIFT_DEFS) {
    const start = DateTime.fromISO(`${dt.toISODate()}T${s.start}`, { zone: TZ });
    const end   = DateTime.fromISO(`${dt.toISODate()}T${s.end}`,   { zone: TZ });
    if (dt < start) return start;
    if (dt >= start && dt < end) return dt; // inside shift already
  }
  // past 2nd shift → next day 1st shift
  return DateTime.fromISO(`${dt.plus({ days: 1 }).toISODate()}T${SHIFT_DEFS[0].start}`, { zone: TZ });
}

export function advancePastShiftEnd(dt: DateTime): DateTime {
  for (const s of SHIFT_DEFS) {
    const end = DateTime.fromISO(`${dt.toISODate()}T${s.end}`, { zone: TZ });
    if (dt < end) return end;
  }
  return roundToShiftStart(dt.plus({ days: 1 }));
}
```

### 2  Patch `server/operator-availability-manager.ts`

*Add below existing imports.*

```ts
import { DateTime } from "luxon";
import { roundToShiftStart, advancePastShiftEnd } from "./shift-utils";
```

*Add new functions at bottom of file.*

```ts
export function getNextAvailableWindow(
  operatorId: string,
  durationHrs: number,
  earliestStart: Date
): { start: Date; end: Date } {
  let dt = roundToShiftStart(DateTime.fromJSDate(earliestStart));
  while (true) {
    if (isOperatorAvailable(operatorId, dt.toJSDate(), durationHrs)) {
      const end = dt.plus({ hours: durationHrs });
      return { start: dt.toUTC().toJSDate(), end: end.toUTC().toJSDate() };
    }
    dt = advancePastShiftEnd(dt);
  }
}

export function lockOperatorUntil(opId: string, until: Date) {
  // simple in‑memory lock; extend if DB persistence is required
  operatorLocks.set(opId, until);
}
```

*(Assumes an existing **`operatorLocks: Map<string, Date>`** in file; create if absent.)*

### 3  Add `server/auto-scheduler.ts`

```ts
import { DateTime } from "luxon";
import { getNextAvailableWindow, lockOperatorUntil } from "./operator-availability-manager";
import { roundToShiftStart } from "./shift-utils";
// import selectMachine, selectOperator, persistScheduleEntry from existing modules

export async function scheduleJob(job, routingOps) {
  let earliest = roundToShiftStart(DateTime.fromISO(job.createdDate).plus({ days: 7 }));
  const machineLocks = new Map<string, DateTime>();

  for (const op of routingOps) {
    if (op.isVirtual) continue;

    const machine = await selectMachine(op, machineLocks);
    const operator = await selectOperator(op, machine);
    if (!machine || !operator) throw new Error("Scheduling failed: no resources");

    const { start, end } = getNextAvailableWindow(operator.id, op.durationHrs, earliest.toJSDate());

    await persistScheduleEntry(job.id, op.seq, machine.id, operator.id, start, end);
    machineLocks.set(machine.id, DateTime.fromJSDate(end));
    lockOperatorUntil(operator.id, end);

    // 24h lag after SAW or WATERJET
    earliest = DateTime.fromJSDate(end);
    if (["SAW", "WATERJET"].includes(op.machinePrefix)) {
      earliest = earliest.plus({ days: 1 }).startOf("day");
    }
  }
}
```

### 4  Replace stubs in `server/database-storage.ts`

```diff
-import { autoScheduleJob } from "./placeholder";
+import { scheduleJob } from "./auto-scheduler";
@@
-export async function scheduleJobsByPriority(max = 100) {
-  return []; // TODO
-}
+export async function scheduleJobsByPriority(max = 100) {
+  const jobs = await db.jobs.findMany({
+    where: { status: "Unscheduled" },
+    orderBy: [{ priority: "desc" }, { promisedDate: "asc" }],
+    take: max,
+  });
+  for (const job of jobs) {
+    const routing = await db.routing.findMany({ where: { jobId: job.id }, orderBy: { seq: "asc" } });
+    await scheduleJob(job, routing);
+    await db.jobs.update({ where: { id: job.id }, data: { status: "Scheduled" } });
+  }
+}
```

### 5  (OPTIONAL) add minimal regression test  `tests/test-operator-locking.js`

*Omitted for brevity; not required for runtime.*

### 6  Commit & push **only Section B**

```bash
git add package.json package-lock.json \
        server/shift-utils.ts server/auto-scheduler.ts \
        server/operator-availability-manager.ts \
        server/database-storage.ts

git commit -m "feat(scheduler): operator‑aligned scheduling, shift rounding, locks"
git push origin main
```

---

## DONE  ✅

Restart dev server after each section.  Verify:

1. Importing CSV logs **no unknown‑work‑center warnings**.
2. `POST /api/jobs/schedule-all` produces schedule entries whose `startTime` ≥ operator shift start and no overlapping operator bookings.

