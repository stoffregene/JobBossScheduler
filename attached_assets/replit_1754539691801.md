Manufacturing Resource Planning (MRP) SystemOverviewThis is a comprehensive Manufacturing Resource Planning (MRP) system designed for real-time job scheduling, machine monitoring, resource allocation, and production management in manufacturing operations. The system aims to provide a modern full-stack solution to optimize production workflows, manage resources efficiently, and provide real-time insights into manufacturing processes, ultimately enhancing operational efficiency and enabling data-driven decision-making in manufacturing.User PreferencesPreferred communication style: Simple, everyday language.AI Agent InstructionsPrompt: Implement Shift Capacity Load BalancingThis update implements a new shift-based load balancing system to distribute work more evenly between the 1st and 2nd shifts based on their relative capacity and efficiency.This update requires creating one new file, replacing one existing file, and updating one API endpoint.Part 1: Create New Backend File1. Create shift-capacity-manager.ts:In the server/ directory, create a new file named shift-capacity-manager.ts and paste the entire code block below into it./**
 * @file shift-capacity-manager.ts
 * @description Calculates shift capacity and load to enable intelligent load balancing.
 */
import { Resource, ScheduleEntry } from "@shared/schema";

interface ShiftMetrics {
  totalEffectiveCapacity: number;
  currentLoad: number;
  loadPercentage: number;
}

export class ShiftCapacityManager {
  private resources: Resource[];
  private scheduleEntries: ScheduleEntry[];
  private readonly SHIFT_1_EFFICIENCY = 0.825;
  private readonly SHIFT_2_EFFICIENCY = 0.605;
  private readonly HOURS_PER_WEEK = 40;

  constructor(resources: Resource[], scheduleEntries: ScheduleEntry[]) {
    this.resources = resources;
    this.scheduleEntries = scheduleEntries;
  }

  private getShiftMetrics(): { shift1: ShiftMetrics, shift2: ShiftMetrics } {
    const shift1Resources = this.resources.filter(r => r.shiftSchedule.includes(1));
    const shift2Resources = this.resources.filter(r => r.shiftSchedule.includes(2));

    const totalCapacity1 = shift1Resources.length * this.HOURS_PER_WEEK * this.SHIFT_1_EFFICIENCY;
    const totalCapacity2 = shift2Resources.length * this.HOURS_PER_WEEK * this.SHIFT_2_EFFICIENCY;

    const load1 = this.scheduleEntries
      .filter(e => e.shift === 1)
      .reduce((sum, e) => sum + (e.endTime.getTime() - e.startTime.getTime()) / 3600000, 0);

    const load2 = this.scheduleEntries
      .filter(e => e.shift === 2)
      .reduce((sum, e) => sum + (e.endTime.getTime() - e.startTime.getTime()) / 3600000, 0);

    return {
      shift1: {
        totalEffectiveCapacity: totalCapacity1,
        currentLoad: load1,
        loadPercentage: totalCapacity1 > 0 ? (load1 / totalCapacity1) * 100 : 100,
      },
      shift2: {
        totalEffectiveCapacity: totalCapacity2,
        currentLoad: load2,
        loadPercentage: totalCapacity2 > 0 ? (load2 / totalCapacity2) * 100 : 100,
      }
    };
  }

  public getOptimalShift(): 1 | 2 {
    const metrics = this.getShiftMetrics();
    if (metrics.shift1.loadPercentage <= metrics.shift2.loadPercentage) {
      return 1;
    }
    return 2;
  }
}
Part 2: Replace Existing Backend File1. Replace scheduler.ts:Open the existing server/scheduler.ts file, delete all of its current contents, and replace them with the code below. This version includes the corrected logic for finding compatible machines./**
 * @file scheduler.ts
 * @description A robust scheduler that now includes shift-based load balancing.
 */
import { Job, Machine, RoutingOperation, ScheduleEntry, Resource } from '../shared/schema';
import { IStorage } from './storage-interface';
import { OperatorAvailabilityManager } from './operator-availability';
import { ShiftCapacityManager } from './shift-capacity-manager';

export interface ScheduleChunk { machine: Machine; resource: Resource; startTime: Date; endTime: Date; shift: number; }
export interface JobScheduleResult { success: boolean; scheduledEntries: ScheduleEntry[]; failureReason?: string; }

export class JobScheduler {
  private storage: IStorage;
  private operatorManager: OperatorAvailabilityManager;
  private shiftCapacityManager: ShiftCapacityManager;

  constructor(storage: IStorage, operatorManager: OperatorAvailabilityManager, allResources: Resource[], allEntries: ScheduleEntry[]) {
    this.storage = storage;
    this.operatorManager = operatorManager;
    this.shiftCapacityManager = new ShiftCapacityManager(allResources, allEntries);
  }

  public async scheduleJob(jobId: string, scheduleAfter: Date = new Date()): Promise<JobScheduleResult> {
    const job = await this.storage.getJob(jobId);
    if (!job) return { success: false, scheduledEntries: [], failureReason: 'Job not found.' };

    const allOps = await this.storage.getRoutingOperationsByJobId(jobId);
    const opsToSchedule = allOps.sort((a, b) => a.sequence - b.sequence);
    
    const allScheduledEntries: ScheduleEntry[] = [];
    let boundaryTime = scheduleAfter;

    for (const op of opsToSchedule) {
      if (op.machineType.toUpperCase().includes('INSPECT')) {
        continue;
      }
      
      const earliestStartTime = this.getEarliestStartTimeForOperation(op, boundaryTime);
      const chunkResult = await this.scheduleOperationInChunks(job, op, earliestStartTime);

      if (!chunkResult.success) {
        return { success: false, scheduledEntries: allScheduledEntries, failureReason: `Failed on Op ${op.sequence}: Could not find a suitable machine.` };
      }
      
      const entriesForOperation = chunkResult.chunks.map(chunk => ({
        id: '', jobId: job.id, machineId: chunk.machine.id, assignedResourceId: chunk.resource.id,
        operationSequence: op.sequence, startTime: chunk.startTime, endTime: chunk.endTime,
        shift: chunk.shift, status: 'Scheduled',
      } as ScheduleEntry));

      allScheduledEntries.push(...entriesForOperation);
      boundaryTime = chunkResult.chunks[chunkResult.chunks.length - 1].endTime;
    }
    
    return { success: true, scheduledEntries: allScheduledEntries };
  }
  
  private async scheduleOperationInChunks(job, operation, searchFromDate) {
    let remainingDurationMs = (parseFloat(operation.estimatedHours) + (parseFloat(operation.setupHours) || 0)) * 3600000;
    let currentTime = new Date(searchFromDate);
    const scheduledChunks: ScheduleChunk[] = [];
    let lockedMachine: Machine | null = null, lockedResource: Resource | null = null;

    while (remainingDurationMs > 0) {
      const nextChunk = await this.findNextAvailableChunk(job, operation, currentTime, lockedMachine, lockedResource);
      if (!nextChunk) return { success: false, chunks: [] };
      
      if (!lockedMachine) lockedMachine = nextChunk.machine;
      if (!lockedResource) lockedResource = nextChunk.resource;

      const chunkDurationMs = nextChunk.endTime.getTime() - nextChunk.startTime.getTime();
      const durationToSchedule = Math.min(remainingDurationMs, chunkDurationMs);
      const finalChunk = { ...nextChunk, endTime: new Date(nextChunk.startTime.getTime() + durationToSchedule) };

      scheduledChunks.push(finalChunk);
      remainingDurationMs -= durationToSchedule;
      currentTime = finalChunk.endTime;
    }
    return { success: true, chunks: scheduledChunks };
  }

  private async findNextAvailableChunk(incomingJob, operation, searchFrom, lockedMachine, lockedResource) {
    const compatibleMachines = lockedMachine ? [lockedMachine] : await this.getCompatibleMachinesForOperation(operation);
    if (compatibleMachines.length === 0) return null;
    
    const optimalShift = this.shiftCapacityManager.getOptimalShift();
    const shiftsToTry = optimalShift === 1 ? [1, 2] : [2, 1];

    for (let i = 0; i < 30 * 24 * 60; i++) {
      const currentTime = new Date(searchFrom.getTime() + i * 60 * 1000);
      for (const machine of compatibleMachines) {
        const machineSchedule = await this.storage.getScheduleEntriesForMachine(machine.id);
        const isBusy = machineSchedule.some(e => currentTime >= e.startTime && currentTime < e.endTime);
        if (isBusy) continue;

        const resource = await this.findAvailableResourceForTime(operation, machine, currentTime, lockedResource, shiftsToTry);
        if (resource) {
          const workBlockEnd = await this.calculateContinuousWorkBlock(currentTime, machine, resource.resource, machineSchedule);
          if(workBlockEnd.getTime() > currentTime.getTime()) {
            return { machine, resource: resource.resource, startTime: currentTime, endTime: workBlockEnd, shift: resource.shift };
          }
        }
      }
    }
    return null;
  }

  private async findAvailableResourceForTime(operation, machine, time, lockedResource, shiftsToTry) {
    for (const shift of shiftsToTry) {
      const availableOperators = this.operatorManager.getAvailableOperators(time, shift, undefined, [machine.machineId]);
      const qualifiedOperators = availableOperators.filter(op => {
        if (lockedResource && op.id !== lockedResource.id) return false;
        if (!operation.requiredSkills || operation.requiredSkills.length === 0) return true;
        return operation.requiredSkills.every(skill => op.skills.includes(skill));
      });
      if (qualifiedOperators.length > 0) return { resource: qualifiedOperators[0], shift };
    }
    return null;
  }

  private async calculateContinuousWorkBlock(startTime, machine, resource, machineSchedule) {
      const operatorWorkingHours = this.operatorManager.getOperatorWorkingHours(resource.id, startTime);
      if (!operatorWorkingHours) return startTime;
      const nextJobStart = machineSchedule.filter(e => e.startTime > startTime).sort((a, b) => a.startTime.getTime() - b.startTime.getTime())[0]?.startTime || new Date(startTime.getTime() + 24 * 60 * 60 * 1000);
      return new Date(Math.min(operatorWorkingHours.endTime.getTime(), nextJobStart.getTime()));
  }

  private getEarliestStartTimeForOperation = (op, time) => (op.earliestStartDate && new Date(op.earliestStartDate) > time) ? new Date(op.earliestStartDate) : time;

  private async getCompatibleMachinesForOperation(operation: RoutingOperation): Promise<Machine[]> {
    const allMachines = await this.storage.getMachines();
    const potentialMachines = new Map<string, Machine>();

    // 1. Prioritize the originally quoted machine.
    if (operation.originalQuotedMachineId) {
        const quotedMachine = allMachines.find(m => m.id === operation.originalQuotedMachineId);
        if (quotedMachine) {
            potentialMachines.set(quotedMachine.id, quotedMachine);
            // 2. If quoted machine has a substitution group, add all machines from that group.
            if (quotedMachine.substitutionGroup) {
                const substituteMachines = await this.storage.getMachinesBySubstitutionGroup(quotedMachine.substitutionGroup);
                substituteMachines.forEach(m => potentialMachines.set(m.id, m));
            }
        }
    }

    // 3. Add machines from the operation's explicit compatible list.
    if (operation.compatibleMachines && operation.compatibleMachines.length > 0) {
        operation.compatibleMachines.forEach(machineId => {
            const machine = allMachines.find(m => m.id === machineId);
            if (machine) potentialMachines.set(machine.id, machine);
        });
    }
    
    // 4. As a fallback, if no other options are found, add all machines of the correct type.
    if (potentialMachines.size === 0) {
        allMachines.forEach(m => {
            if (m.type === operation.machineType) {
                potentialMachines.set(m.id, m);
            }
        });
    }
    
    return Array.from(potentialMachines.values());
  }
}
Part 3: Update API EndpointIn your main server file where your API routes are defined (e.g., server/index.ts), find the POST /api/jobs/schedule-all route handler and replace its entire contents with the code below. This new version correctly initializes the scheduler with all the required data.// In your Express server file (e.g., server/index.ts)

// POST /api/jobs/schedule-all
app.post('/api/jobs/schedule-all', async (req, res) => {
  try {
    const storage = getStorage(); // Your method for getting the storage instance

    // 1. Fetch ALL data required by the services upfront
    const allResources = await storage.getResources();
    const allUnavailabilities = await storage.getResourceUnavailabilities();
    const allScheduleEntries = await storage.getScheduleEntries();
    const jobsToSchedule = (await storage.getJobs()).filter(j => j.status === 'Unscheduled');

    if (jobsToSchedule.length === 0) {
      return res.json({ success: true, scheduled: 0, failed: 0, message: "No unscheduled jobs to process." });
    }

    // 2. Initialize the services with the complete dataset
    const operatorManager = new OperatorAvailabilityManager(allResources, allUnavailabilities);
    const scheduler = new JobScheduler(storage, operatorManager, allResources, allScheduleEntries);

    let scheduledCount = 0;
    let failedCount = 0;

    // 3. Loop through and schedule each job
    for (const job of jobsToSchedule) {
      const result = await scheduler.scheduleJob(job.id);
      
      if (result.success && result.scheduledEntries.length > 0) {
        // Save the new schedule entries to the database
        for (const entry of result.scheduledEntries) {
          await storage.createScheduleEntry(entry);
        }
        await storage.updateJob(job.id, { status: 'Scheduled' });
        scheduledCount++;
      } else {
        failedCount++;
        console.error(`Failed to schedule job ${job.jobNumber}: ${result.failureReason}`);
      }
    }

    res.json({ success: true, scheduled: scheduledCount, failed: failedCount });

  } catch (error) {
    console.error("Critical error during full scheduling run:", error);
    res.status(500).json({ success: false, message: 'A critical error occurred during the scheduling run.' });
  }
});
System Architecture(Rest of the file remains the same)External Dependencies(Rest of the file remains the same)